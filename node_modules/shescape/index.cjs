'use strict';

var os = require('os');
var process = require('process');
var fs = require('fs');
var path = require('path');
var which = require('which');
var util = require('util');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);
var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);

/**
 * @overview Provides functionality related to working with executables.
 * @license MPL-2.0
 */

/**
 * Resolves the location of an executable given an arbitrary valid string
 * representation of that executable.
 *
 * To obtain the location of the executable this function (if necessary):
 * - Expands the provided string to an absolute path.
 * - Follows symbolic links.
 *
 * @param {object} args The arguments for this function.
 * @param {object} args.env The environment variables.
 * @param {string} args.executable A string representation of the executable.
 * @param {object} deps The dependencies for this function.
 * @param {Function} deps.exists A function to check if a file exists.
 * @param {Function} deps.readlink A function to resolve (sym)links.
 * @param {Function} deps.which A function to perform a `which(1)`-like lookup.
 * @returns {string} The full path to the binary of the executable.
 */
function resolveExecutable(
  { env, executable },
  { exists, readlink, which },
) {
  try {
    executable = which(executable, { path: env.PATH || env.Path });
  } catch (_) {
    // For backwards compatibility return the executable even if its location
    // cannot be obtained
    return executable;
  }

  if (!exists(executable)) {
    // For backwards compatibility return the executable even if there exists no
    // file at the specified path
    return executable;
  }

  try {
    executable = readlink(executable);
  } catch (_) {
    // An error will be thrown if the executable is not a (sym)link, this is not
    // a problem so the error is ignored
  }

  return executable;
}

/**
 * @overview Provides reflection functionality.
 * @license MPL-2.0
 */

/**
 * The error message for incorrect parameter types.
 *
 * @constant
 * @type {string}
 */
const typeError =
  "Shescape requires strings or values that can be converted into a string using .toString()";

/**
 * The `typeof` value of functions.
 *
 * @constant
 * @type {string}
 */
const typeofFunction = "function";

/**
 * The `typeof` value of strings.
 *
 * @constant
 * @type {string}
 */
const typeofString = "string";

/**
 * Checks if a value can be converted into a string and converts it if possible.
 *
 * @param {any} value The value of interest.
 * @returns {string | null} If possible the string of `value`, otherwise `null`.
 */
function maybeToString(value) {
  if (value === undefined || value === null) {
    return null;
  }

  if (typeof value.toString !== typeofFunction) {
    return null;
  }

  const maybeStr = value.toString();
  if (isString(maybeStr)) {
    return maybeStr;
  } else {
    return null;
  }
}

/**
 * Convert a value into a string if that is possible.
 *
 * @param {any} value The value to convert into a string.
 * @returns {string} The `value` as a string.
 * @throws {TypeError} The `value` is not stringable.
 */
function checkedToString(value) {
  if (isString(value)) {
    return value;
  }

  const maybeStr = maybeToString(value);
  if (maybeStr === null) {
    throw new TypeError(typeError);
  }

  return maybeStr;
}

/**
 * Checks if a value is a string.
 *
 * @param {any} value The value of interest.
 * @returns {boolean} `true` if `value` is a string, `false` otherwise.
 */
function isString(value) {
  return typeof value === typeofString;
}

/**
 * Converts the provided value into an array if it is not already an array and
 * returns the array.
 *
 * @param {Array | any} value The value to convert to an array if necessary.
 * @returns {Array} An array containing `value` or `value` itself.
 */
function toArrayIfNecessary(value) {
  return Array.isArray(value) ? value : [value];
}

/**
 * @overview Provides functionality for parsing shescape options.
 * @license MPL-2.0
 */


/**
 * Parses options provided to shescape.
 *
 * @param {object} args The arguments for this function.
 * @param {object} args.env The environment variables.
 * @param {object} args.options The options for escaping.
 * @param {boolean} [args.options.flagProtection] Is flag protection enabled.
 * @param {boolean} [args.options.interpolation] Is interpolation enabled.
 * @param {boolean | string} [args.options.shell] The shell to escape for.
 * @param {object} deps The dependencies for this function.
 * @param {Function} deps.getDefaultShell Function to get the default shell.
 * @param {Function} deps.getShellName Function to get the name of a shell.
 * @returns {object} The parsed arguments.
 */
function parseOptions(
  { env, options: { flagProtection, interpolation, shell } },
  { getDefaultShell, getShellName },
) {
  flagProtection = flagProtection ? true : false;
  interpolation = interpolation ? true : false;
  shell = isString(shell) ? shell : getDefaultShell({ env });

  const shellName = getShellName({ env, shell }, { resolveExecutable });
  return { flagProtection, interpolation, shellName };
}

/**
 * @overview Provides functionality for the Bourne-again shell (Bash).
 * @license MPL-2.0
 */

/**
 * Escape an argument for use in Bash when interpolation is active.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForInterpolation$5(arg) {
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/\\/gu, "\\\\")
    .replace(/(?<=^|\s)([#~])/gu, "\\$1")
    .replace(/(["$&'()*;<>?`{|])/gu, "\\$1")
    .replace(/(?<=[:=])(~)(?=[\s+\-/0:=]|$)/gu, "\\$1")
    .replace(/([\t ])/gu, "\\$1");
}

/**
 * Escape an argument for use in Bash when the argument is not being quoted (but
 * interpolation is inactive).
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForNoInterpolation$5(arg) {
  return arg.replace(/[\0\u0008\u001B\u009B]/gu, "").replace(/\r(?!\n)/gu, "");
}

/**
 * Returns a function to escape arguments for use in Bash for the given use
 * case.
 *
 * @param {object} options The options for escaping arguments.
 * @param {boolean} options.interpolation Is interpolation enabled.
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$7(options) {
  if (options.interpolation) {
    return escapeArgForInterpolation$5;
  } else {
    return escapeArgForNoInterpolation$5;
  }
}

/**
 * Escape an argument for use in Bash when the argument is being quoted.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForQuoted$5(arg) {
  return arg
    .replace(/[\0\u0008\u001B\u009B]/gu, "")
    .replace(/\r(?!\n)/gu, "")
    .replace(/'/gu, "'\\''");
}

/**
 * Quotes an argument for use in Bash.
 *
 * @param {string} arg The argument to quote.
 * @returns {string} The quoted argument.
 */
function quoteArg$5(arg) {
  return `'${arg}'`;
}

/**
 * Returns a pair of functions to escape and quote arguments for use in Bash.
 *
 * @returns {Function[]} A function pair to escape & quote arguments.
 */
function getQuoteFunction$7() {
  return [escapeArgForQuoted$5, quoteArg$5];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Unix systems for Bash.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix$5(arg) {
  return arg.replace(/^-+/gu, "");
}

/**
 * Returns a function to protect against flag injection for Bash.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$7() {
  return stripFlagPrefix$5;
}

/**
 * @overview Provides functionality for the C shell (csh).
 * @license MPL-2.0
 */


/**
 * Escape an argument for use in csh when interpolation is active.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForInterpolation$4(arg) {
  const textEncoder = new util.TextEncoder();
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/\\/gu, "\\\\")
    .replace(/(?<=^|\s)(~)/gu, "\\$1")
    .replace(/!(?!$)/gu, "\\!")
    .replace(/(["#$&'()*;<>?[`{|])/gu, "\\$1")
    .replace(/([\t ])/gu, "\\$1")
    .split("")
    .map(
      // Due to a bug in C shell version 20110502-7, when a character whose
      // utf-8 encoding includes the bytes 0xA0 (160 in decimal) appears in
      // an argument after an escaped character, it will hang and endlessly
      // consume memory unless the character is escaped with quotes.
      // ref: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=995013
      (char) => (textEncoder.encode(char).includes(160) ? `'${char}'` : char),
    )
    .join("");
}

/**
 * Escape an argument for use in csh when the argument is not being quoted (but
 * interpolation is inactive).
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForNoInterpolation$4(arg) {
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/\\!$/gu, "\\\\!")
    .replace(/!(?!$)/gu, "\\!");
}

/**
 * Returns a function to escape arguments for use in csh for the given use case.
 *
 * @param {object} options The options for escaping arguments.
 * @param {boolean} options.interpolation Is interpolation enabled.
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$6(options) {
  if (options.interpolation) {
    return escapeArgForInterpolation$4;
  } else {
    return escapeArgForNoInterpolation$4;
  }
}

/**
 * Escape an argument for use in csh when the argument is being quoted.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForQuoted$4(arg) {
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/'/gu, "'\\''")
    .replace(/\\!$/gu, "\\\\!")
    .replace(/!(?!$)/gu, "\\!");
}

/**
 * Quotes an argument for use in csh.
 *
 * @param {string} arg The argument to quote.
 * @returns {string} The quoted argument.
 */
function quoteArg$4(arg) {
  return `'${arg}'`;
}

/**
 * Returns a pair of functions to escape and quote arguments for use in csh.
 *
 * @returns {Function[]} A function pair to escape & quote arguments.
 */
function getQuoteFunction$6() {
  return [escapeArgForQuoted$4, quoteArg$4];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Unix systems for csh.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix$4(arg) {
  return arg.replace(/^-+/gu, "");
}

/**
 * Returns a function to protect against flag injection for csh.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$6() {
  return stripFlagPrefix$4;
}

/**
 * @overview Provides functionality for the Debian Almquist shell (Dash).
 * @license MPL-2.0
 */

/**
 * Escape an argument for use in Dash when interpolation is active.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForInterpolation$3(arg) {
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/\\/gu, "\\\\")
    .replace(/(?<=^|\s)([#~])/gu, "\\$1")
    .replace(/(["$&'()*;<>?`|])/gu, "\\$1")
    .replace(/([\t ])/gu, "\\$1");
}

/**
 * Escape an argument for use in Dash when the argument is not being quoted (but
 * interpolation is inactive).
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForNoInterpolation$3(arg) {
  return arg.replace(/[\0\u0008\u001B\u009B]/gu, "").replace(/\r(?!\n)/gu, "");
}

/**
 * Returns a function to escape arguments for use in Dash for the given use
 * case.
 *
 * @param {object} options The options for escaping arguments.
 * @param {boolean} options.interpolation Is interpolation enabled.
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$5(options) {
  if (options.interpolation) {
    return escapeArgForInterpolation$3;
  } else {
    return escapeArgForNoInterpolation$3;
  }
}

/**
 * Escape an argument for use in Dash when the argument is being quoted.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForQuoted$3(arg) {
  return arg
    .replace(/[\0\u0008\u001B\u009B]/gu, "")
    .replace(/\r(?!\n)/gu, "")
    .replace(/'/gu, "'\\''");
}

/**
 * Quotes an argument for use in Dash.
 *
 * @param {string} arg The argument to quote.
 * @returns {string} The quoted argument.
 */
function quoteArg$3(arg) {
  return `'${arg}'`;
}

/**
 * Returns a pair of functions to escape and quote arguments for use in Dash.
 *
 * @returns {Function[]} A function pair to escape & quote arguments.
 */
function getQuoteFunction$5() {
  return [escapeArgForQuoted$3, quoteArg$3];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Unix systems for Dash.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix$3(arg) {
  return arg.replace(/^-+/gu, "");
}

/**
 * Returns a function to protect against flag injection for Dash.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$5() {
  return stripFlagPrefix$3;
}

/**
 * @overview Provides functionality for the Z shell (Zsh).
 * @license MPL-2.0
 */

/**
 * Escape an argument for use in Zsh when interpolation is active.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForInterpolation$2(arg) {
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/\\/gu, "\\\\")
    .replace(/(?<=^|\s)([#=~])/gu, "\\$1")
    .replace(/(["$&'()*;<>?[\]`{|}])/gu, "\\$1")
    .replace(/([\t ])/gu, "\\$1");
}

/**
 * Escape an argument for use in Zsh when the argument is not being quoted (but
 * interpolation is inactive).
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForNoInterpolation$2(arg) {
  return arg.replace(/[\0\u0008\u001B\u009B]/gu, "").replace(/\r(?!\n)/gu, "");
}

/**
 * Returns a function to escape arguments for use in Zsh for the given use case.
 *
 * @param {object} options The options for escaping arguments.
 * @param {boolean} options.interpolation Is interpolation enabled.
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$4(options) {
  if (options.interpolation) {
    return escapeArgForInterpolation$2;
  } else {
    return escapeArgForNoInterpolation$2;
  }
}

/**
 * Escape an argument for use in Zsh when the argument is being quoted.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForQuoted$2(arg) {
  return arg
    .replace(/[\0\u0008\u001B\u009B]/gu, "")
    .replace(/\r(?!\n)/gu, "")
    .replace(/'/gu, "'\\''");
}

/**
 * Quotes an argument for use in Zsh.
 *
 * @param {string} arg The argument to quote.
 * @returns {string} The quoted argument.
 */
function quoteArg$2(arg) {
  return `'${arg}'`;
}

/**
 * Returns a pair of functions to escape and quote arguments for use in Zsh.
 *
 * @returns {Function[]} A function pair to escape & quote arguments.
 */
function getQuoteFunction$4() {
  return [escapeArgForQuoted$2, quoteArg$2];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Unix systems for Zsh.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix$2(arg) {
  return arg.replace(/^-+/gu, "");
}

/**
 * Returns a function to protect against flag injection for Zsh.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$4() {
  return stripFlagPrefix$2;
}

/**
 * @overview Provides functionality for Unix systems.
 * @license MPL-2.0
 */


/**
 * The name of the Bourne-again shell (Bash) binary.
 *
 * @constant
 * @type {string}
 */
const binBash = "bash";

/**
 * The name of the C shell (csh) binary.
 *
 * @constant
 * @type {string}
 */
const binCsh = "csh";

/**
 * The name of the Debian Almquist shell (Dash) binary.
 *
 * @constant
 * @type {string}
 */
const binDash = "dash";

/**
 * The name of the Z shell (Zsh) binary.
 *
 * @constant
 * @type {string}
 */
const binZsh = "zsh";

/**
 * Returns the default shell for Unix systems.
 *
 * For more information, see `options.shell` in:
 * https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback.
 *
 * @returns {string} The default shell.
 */
function getDefaultShell$1() {
  return "/bin/sh";
}

/**
 * Returns a function to escape arguments for use in a particular shell.
 *
 * @param {string} shellName The name of a Unix shell.
 * @param {object} options The options for escaping arguments.
 * @param {boolean} options.interpolation Is interpolation enabled.
 * @returns {Function | undefined} A function to escape arguments.
 */
function getEscapeFunction$3(shellName, options) {
  switch (shellName) {
    case binBash:
      return getEscapeFunction$7(options);
    case binCsh:
      return getEscapeFunction$6(options);
    case binDash:
      return getEscapeFunction$5(options);
    case binZsh:
      return getEscapeFunction$4(options);
  }
}

/**
 * Returns a pair of functions to escape and quote arguments for use in a
 * particular shell.
 *
 * @param {string} shellName The name of a Unix shell.
 * @returns {Function[] | undefined} A function pair to escape & quote arguments.
 */
function getQuoteFunction$3(shellName) {
  switch (shellName) {
    case binBash:
      return getQuoteFunction$7();
    case binCsh:
      return getQuoteFunction$6();
    case binDash:
      return getQuoteFunction$5();
    case binZsh:
      return getQuoteFunction$4();
  }
}

/**
 * Returns a function to protect against flag injection.
 *
 * @param {string} shellName The name of a Unix shell.
 * @returns {Function | undefined} A function to protect against flag injection.
 */
function getFlagProtectionFunction$3(shellName) {
  switch (shellName) {
    case binBash:
      return getFlagProtectionFunction$7();
    case binCsh:
      return getFlagProtectionFunction$6();
    case binDash:
      return getFlagProtectionFunction$5();
    case binZsh:
      return getFlagProtectionFunction$4();
  }
}

/**
 * Determines the name of the shell identified by a file path or file name.
 *
 * @param {object} args The arguments for this function.
 * @param {object} args.env The environment variables.
 * @param {string} args.shell The name or path of the shell.
 * @param {object} deps The dependencies for this function.
 * @param {Function} deps.resolveExecutable Resolve the path to an executable.
 * @returns {string} The shell name.
 */
function getShellName$1({ env, shell }, { resolveExecutable }) {
  shell = resolveExecutable(
    { env, executable: shell },
    { exists: fs__namespace.existsSync, readlink: fs__namespace.readlinkSync, which: which.sync },
  );

  const shellName = path__namespace.basename(shell);
  if (getEscapeFunction$3(shellName, {}) === undefined) {
    return binBash;
  }

  return shellName;
}

var unix = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getDefaultShell: getDefaultShell$1,
  getEscapeFunction: getEscapeFunction$3,
  getFlagProtectionFunction: getFlagProtectionFunction$3,
  getQuoteFunction: getQuoteFunction$3,
  getShellName: getShellName$1
});

/**
 * @overview Provides functionality for the Windows Command Prompt.
 * @license MPL-2.0
 */

/**
 * Escape an argument for use in CMD when interpolation is active.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForInterpolation$1(arg) {
  let shouldEscapeSpecialChar = true;
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/(?<!\\)(\\*)"/gu, '$1$1\\"')
    .split("")
    .map(
      // Due to the way CMD determines if it is inside a quoted section, and the
      // way we escape double quotes, whether or not special character need to
      // be escaped depends on the number of double quotes that proceed it. So,
      // we flip a flag for every double quote we encounter and escape special
      // characters conditionally on that flag.
      (char) => {
        if (char === '"') {
          shouldEscapeSpecialChar = !shouldEscapeSpecialChar;
        } else if (shouldEscapeSpecialChar && /[%&<>^|]/u.test(char)) {
          return `^${char}`;
        }

        return char;
      },
    )
    .join("");
}

/**
 * Escape an argument for use in CMD when the argument is not being quoted (but
 * interpolation is inactive).
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForNoInterpolation$1(arg) {
  return arg.replace(/[\0\u0008\r\u001B\u009B]/gu, "").replace(/\n/gu, " ");
}

/**
 * Returns a function to escape arguments for use in CMD for the given use case.
 *
 * @param {object} options The options for escaping arguments.
 * @param {boolean} options.interpolation Is interpolation enabled.
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$2(options) {
  if (options.interpolation) {
    return escapeArgForInterpolation$1;
  } else {
    return escapeArgForNoInterpolation$1;
  }
}

/**
 * Escape an argument for use in CMD when the argument is being quoted.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForQuoted$1(arg) {
  return escapeArgForInterpolation$1(arg).replace(
    /(?<!\\)(\\*)([\t ])/gu,
    "$1$1$2",
  );
}

/**
 * Quotes an argument for use in CMD.
 *
 * @param {string} arg The argument to quote.
 * @returns {string} The quoted argument.
 */
function quoteArg$1(arg) {
  return arg.replace(/([\t ]+)/gu, '"$1"');
}

/**
 * Returns a pair of functions to escape and quote arguments for use in CMD.
 *
 * @returns {Function[]} A function pair to escape & quote arguments.
 */
function getQuoteFunction$2() {
  return [escapeArgForQuoted$1, quoteArg$1];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Windows systems for CMD.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix$1(arg) {
  return arg.replace(/^(?:-+|\/+)/gu, "");
}

/**
 * Returns a function to protect against flag injection for CMD.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$2() {
  return stripFlagPrefix$1;
}

/**
 * @overview Provides functionality for Windows PowerShell.
 * @license MPL-2.0
 */

/**
 * Escape an argument for use in PowerShell when interpolation is active.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForInterpolation(arg) {
  arg = arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/`/gu, "``")
    .replace(/(?<=^|[\s\u0085])([*1-6]?)(>)/gu, "$1`$2")
    .replace(/(?<=^|[\s\u0085])([#\-:<@\]])/gu, "`$1")
    .replace(/([$&'(),;{|}‘’‚‛“”„])/gu, "`$1");

  if (/[\s\u0085]/u.test(arg.replace(/^[\s\u0085]+/gu, ""))) {
    arg = arg
      .replace(/(?<!\\)(\\*)"/gu, '$1$1`"`"')
      .replace(/(?<!\\)(\\+)$/gu, "$1$1");
  } else {
    arg = arg.replace(/(?<!\\)(\\*)"/gu, '$1$1\\`"');
  }

  arg = arg.replace(/([\s\u0085])/gu, "`$1");

  return arg;
}

/**
 * Escape an argument for use in PowerShell when the argument is not being
 * quoted (but interpolation is inactive).
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForNoInterpolation(arg) {
  return arg.replace(/[\0\u0008\u001B\u009B]/gu, "").replace(/\r(?!\n)/gu, "");
}

/**
 * Returns a function to escape arguments for use in PowerShell for the given
 * use case.
 *
 * @param {object} options The options for escaping arguments.
 * @param {boolean} options.interpolation Is interpolation enabled.
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$1(options) {
  if (options.interpolation) {
    return escapeArgForInterpolation;
  } else {
    return escapeArgForNoInterpolation;
  }
}

/**
 * Escape an argument for use in PowerShell when the argument is being quoted.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForQuoted(arg) {
  arg = arg
    .replace(/[\0\u0008\u001B\u009B]/gu, "")
    .replace(/\r(?!\n)/gu, "")
    .replace(/(['‘’‚‛])/gu, "$1$1");

  if (/[\s\u0085]/u.test(arg)) {
    arg = arg
      .replace(/(?<!\\)(\\*)"/gu, '$1$1""')
      .replace(/(?<!\\)(\\+)$/gu, "$1$1");
  } else {
    arg = arg.replace(/(?<!\\)(\\*)"/gu, '$1$1\\"');
  }

  return arg;
}

/**
 * Quotes an argument for use in PowerShell.
 *
 * @param {string} arg The argument to quote and escape.
 * @returns {string} The quoted and escaped argument.
 */
function quoteArg(arg) {
  return `'${arg}'`;
}

/**
 * Returns a pair of functions to escape and quote arguments for use in
 * PowerShell.
 *
 * @returns {Function[]} A function pair to escape & quote arguments.
 */
function getQuoteFunction$1() {
  return [escapeArgForQuoted, quoteArg];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Windows systems for PowerShell.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix(arg) {
  return arg.replace(/^(?:`?-+|\/+)/gu, "");
}

/**
 * Returns a function to protect against flag injection for PowerShell.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$1() {
  return stripFlagPrefix;
}

/**
 * @overview Provides functionality for Windows systems.
 * @license MPL-2.0
 */


/**
 * The name of the Windows Command Prompt binary.
 *
 * @constant
 * @type {string}
 */
const binCmd = "cmd.exe";

/**
 * The name of the Windows PowerShell binary.
 *
 * @constant
 * @type {string}
 */
const binPowerShell = "powershell.exe";

/**
 * Returns the default shell for Windows systems.
 *
 * For more information, see:
 * https://nodejs.org/api/child_process.html#default-windows-shell.
 *
 * @param {object} args The arguments for this function.
 * @param {object} args.env The environment variables.
 * @param {string} [args.env.ComSpec] The %COMSPEC% value.
 * @returns {string} The default shell.
 */
function getDefaultShell({ env: { ComSpec } }) {
  if (ComSpec !== undefined) {
    return ComSpec;
  }

  return binCmd;
}

/**
 * Returns a function to escape arguments for use in a particular shell.
 *
 * @param {string} shellName The name of a Windows shell.
 * @param {object} options The options for escaping arguments.
 * @param {boolean} options.interpolation Is interpolation enabled.
 * @returns {Function | undefined} A function to escape arguments.
 */
function getEscapeFunction(shellName, options) {
  switch (shellName.toLowerCase()) {
    case binCmd:
      return getEscapeFunction$2(options);
    case binPowerShell:
      return getEscapeFunction$1(options);
  }
}

/**
 * Returns a pair of functions to escape and quote arguments for use in a
 * particular shell.
 *
 * @param {string} shellName The name of a Windows shell.
 * @returns {Function[] | undefined} A function pair to escape & quote arguments.
 */
function getQuoteFunction(shellName) {
  switch (shellName.toLowerCase()) {
    case binCmd:
      return getQuoteFunction$2();
    case binPowerShell:
      return getQuoteFunction$1();
  }
}

/**
 * Returns a function to protect against flag injection.
 *
 * @param {string} shellName The name of a Windows shell.
 * @returns {Function | undefined} A function to protect against flag injection.
 */
function getFlagProtectionFunction(shellName) {
  switch (shellName.toLowerCase()) {
    case binCmd:
      return getFlagProtectionFunction$2();
    case binPowerShell:
      return getFlagProtectionFunction$1();
  }
}

/**
 * Determines the name of the shell identified by a file path or file name.
 *
 * @param {object} args The arguments for this function.
 * @param {object} args.env The environment variables.
 * @param {string} args.shell The name or path of the shell.
 * @param {object} deps The dependencies for this function.
 * @param {Function} deps.resolveExecutable Resolve the path to an executable.
 * @returns {string} The shell name.
 */
function getShellName({ env, shell }, { resolveExecutable }) {
  shell = resolveExecutable(
    { env, executable: shell },
    { exists: fs__namespace.existsSync, readlink: fs__namespace.readlinkSync, which: which.sync },
  );

  const shellName = path__namespace.win32.basename(shell);
  if (getEscapeFunction(shellName, {}) === undefined) {
    return binCmd;
  }

  return shellName;
}

var win = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getDefaultShell: getDefaultShell,
  getEscapeFunction: getEscapeFunction,
  getFlagProtectionFunction: getFlagProtectionFunction,
  getQuoteFunction: getQuoteFunction,
  getShellName: getShellName
});

/**
 * @overview Provides functionality related to getting the platform module for
 * the current system.
 * @license MPL-2.0
 */


/**
 * The string identifying the OS type Cygwin.
 *
 * @constant
 * @type {string}
 */
const cygwin = "cygwin";

/**
 * The string identifying the OS type MSYS.
 *
 * @constant
 * @type {string}
 */
const msys = "msys";

/**
 * The string identifying Windows platforms.
 *
 * @constant
 * @type {string}
 */
const win32 = "win32";

/**
 * Checks if the current system is a Windows system.
 *
 * @param {object} args The arguments for this function.
 * @param {Object<string, string>} args.env The environment variables.
 * @param {string} args.platform The `os.platform()` value.
 * @returns {boolean} `true` if the system is Windows, `false` otherwise.
 */
function isWindow({ env, platform }) {
  return env.OSTYPE === cygwin || env.OSTYPE === msys || platform === win32;
}

/**
 * Returns all helper functions for a specific system.
 *
 * @param {object} args The arguments for this function.
 * @param {Object<string, string>} args.env The environment variables.
 * @param {string} args.platform The `os.platform()` value.
 * @returns {object} The helper functions for the current system.
 */
function getHelpersByPlatform({ env, platform }) {
  if (isWindow({ env, platform })) {
    return win;
  }

  return unix;
}

/**
 * A simple shell escape library. Use it to escape user-controlled inputs to
 * shell commands to prevent shell injection.
 *
 * @overview Entrypoint for the library.
 * @module shescape
 * @version 1.7.4
 * @license MPL-2.0
 */


/**
 * Get the helper functions for the current platform.
 *
 * @returns {object} The helper functions for the current platform.
 */
function getPlatformHelpers() {
  const platform = os.platform();
  const helpers = getHelpersByPlatform({ env: process.env, platform });
  return helpers;
}

/**
 * Take a single value, the argument, and escape any dangerous characters.
 *
 * Non-string inputs will be converted to strings using a `toString()` method.
 *
 * NOTE: when the `interpolation` option is set to `true`, whitespace is escaped
 * to prevent argument splitting except for cmd.exe (which does not support it).
 *
 * @example
 * import { spawn } from "node:child_process";
 * spawn(
 *   "echo",
 *   ["Hello", shescape.escape(userInput)],
 *   null // `options.shell` MUST be falsy
 * );
 * @param {string} arg The argument to escape.
 * @param {object} [options] The escape options.
 * @param {boolean} [options.flagProtection=false] Is flag protection enabled.
 * @param {boolean} [options.interpolation=false] Is interpolation enabled.
 * @param {boolean | string} [options.shell] The shell to escape for.
 * @returns {string} The escaped argument.
 * @throws {TypeError} The argument is not stringable.
 * @since 0.1.0
 */
function escape(arg, options = {}) {
  const helpers = getPlatformHelpers();
  const { flagProtection, interpolation, shellName } = parseOptions(
    { env: process.env, options },
    helpers,
  );
  const argAsString = checkedToString(arg);
  const escape = helpers.getEscapeFunction(shellName, { interpolation });
  const escapedArg = escape(argAsString);
  if (flagProtection) {
    const flagProtect = helpers.getFlagProtectionFunction(shellName);
    return flagProtect(escapedArg);
  } else {
    return escapedArg;
  }
}

/**
 * Take an array of values, the arguments, and escape any dangerous characters
 * in every argument.
 *
 * Non-array inputs will be converted to one-value arrays and non-string values
 * will be converted to strings using a `toString()` method.
 *
 * @example
 * import { spawn } from "node:child_process";
 * spawn(
 *   "echo",
 *   shescape.escapeAll(["Hello", userInput]),
 *   null // `options.shell` MUST be falsy
 * );
 * @param {string[]} args The arguments to escape.
 * @param {object} [options] The escape options.
 * @param {boolean} [options.flagProtection=false] Is flag protection enabled.
 * @param {boolean} [options.interpolation=false] Is interpolation enabled.
 * @param {boolean | string} [options.shell] The shell to escape for.
 * @returns {string[]} The escaped arguments.
 * @throws {TypeError} One of the arguments is not stringable.
 * @since 1.1.0
 */
function escapeAll(args, options = {}) {
  args = toArrayIfNecessary(args);
  return args.map((arg) => escape(arg, options));
}

/**
 * Take a single value, the argument, put shell-specific quotes around it and
 * escape any dangerous characters.
 *
 * Non-string inputs will be converted to strings using a `toString()` method.
 *
 * @example
 * import { spawn } from "node:child_process";
 * const spawnOptions = { shell: true }; // `options.shell` SHOULD be truthy
 * const shescapeOptions = { shell: spawnOptions.shell };
 * spawn(
 *   "echo",
 *   ["Hello", shescape.quote(userInput, shescapeOptions)],
 *   spawnOptions
 * );
 * @example
 * import { exec } from "node:child_process";
 * const execOptions = null || { };
 * const shescapeOptions = { shell: execOptions.shell };
 * exec(
 *   `echo Hello ${shescape.quote(userInput, shescapeOptions)}`,
 *   execOptions
 * );
 * @param {string} arg The argument to quote and escape.
 * @param {object} [options] The escape and quote options.
 * @param {boolean} [options.flagProtection=false] Is flag protection enabled.
 * @param {boolean | string} [options.shell] The shell to escape for.
 * @returns {string} The quoted and escaped argument.
 * @throws {TypeError} The argument is not stringable.
 * @since 0.3.0
 */
function quote(arg, options = {}) {
  const helpers = getPlatformHelpers();
  const { flagProtection, shellName } = parseOptions(
    { env: process.env, options },
    helpers,
  );
  const argAsString = checkedToString(arg);
  const [escape, quote] = helpers.getQuoteFunction(shellName);
  const escapedArg = escape(argAsString);
  if (flagProtection) {
    const flagProtect = helpers.getFlagProtectionFunction(shellName);
    return quote(flagProtect(escapedArg));
  } else {
    return quote(escapedArg);
  }
}

/**
 * Take an array of values, the arguments, put shell-specific quotes around
 * every argument and escape any dangerous characters in every argument.
 *
 * Non-array inputs will be converted to one-value arrays and non-string values
 * will be converted to strings using a `toString()` method.
 *
 * @example
 * import { spawn } from "node:child_process";
 * const spawnOptions = { shell: true }; // `options.shell` SHOULD be truthy
 * const shescapeOptions = { shell: spawnOptions.shell };
 * spawn(
 *   "echo",
 *   shescape.quoteAll(["Hello", userInput], shescapeOptions),
 *   spawnOptions
 * );
 * @param {string[]} args The arguments to quote and escape.
 * @param {object} [options] The escape and quote options.
 * @param {boolean} [options.flagProtection=false] Is flag protection enabled.
 * @param {boolean | string} [options.shell] The shell to escape for.
 * @returns {string[]} The quoted and escaped arguments.
 * @throws {TypeError} One of the arguments is not stringable.
 * @since 0.4.0
 */
function quoteAll(args, options = {}) {
  args = toArrayIfNecessary(args);
  return args.map((arg) => quote(arg, options));
}

exports.escape = escape;
exports.escapeAll = escapeAll;
exports.quote = quote;
exports.quoteAll = quoteAll;
