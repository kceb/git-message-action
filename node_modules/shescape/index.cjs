'use strict';

var os = require('node:os');
var process = require('node:process');
var fs = require('node:fs');
var path = require('node:path');
var which = require('which');
var node_util = require('node:util');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);
var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);

/**
 * @overview Provides reflection functionality.
 * @license MPL-2.0
 */

/**
 * The error message for incorrect parameter types.
 *
 * @constant
 * @type {string}
 */
const typeError =
  "Shescape requires strings or values that can be converted into a string using .toString()";

/**
 * The `typeof` value of functions.
 *
 * @constant
 * @type {string}
 */
const typeofFunction = "function";

/**
 * The `typeof` value of strings.
 *
 * @constant
 * @type {string}
 */
const typeofString = "string";

/**
 * Check if the given object has the given property as an own property.
 *
 * This custom function is used over `Object.hasOwn` because that isn't
 * available in all supported Node.js versions.
 *
 * @param {object} object The object of interest.
 * @param {string} property The property of interest.
 * @returns {boolean} `true` if property is an own-property, `false` otherwise.
 */
function hasOwn(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}

/**
 * Checks if a value can be converted into a string and converts it if possible.
 *
 * @param {any} value The value of interest.
 * @returns {string | null} If possible the string of `value`, otherwise `null`.
 */
function maybeToString(value) {
  if (value === undefined || value === null) {
    return null;
  }

  if (typeof value.toString !== typeofFunction) {
    return null;
  }

  const maybeStr = value.toString();
  if (isString(maybeStr)) {
    return maybeStr;
  } else {
    return null;
  }
}

/**
 * Convert a value into a string if that is possible.
 *
 * @param {any} value The value to convert into a string.
 * @returns {string} The `value` as a string.
 * @throws {TypeError} The `value` is not stringable.
 */
function checkedToString(value) {
  if (isString(value)) {
    return value;
  }

  const maybeStr = maybeToString(value);
  if (maybeStr === null) {
    throw new TypeError(typeError);
  }

  return maybeStr;
}

/**
 * Checks if a value is a string.
 *
 * @param {any} value The value of interest.
 * @returns {boolean} `true` if `value` is a string, `false` otherwise.
 */
function isString(value) {
  return typeof value === typeofString;
}

/**
 * @overview Provides functionality related to working with executables.
 * @license MPL-2.0
 */


/**
 * Build error messages for when executables cannot be found.
 *
 * @param {string} executable The executable being looked up.
 * @returns {string} The executable not found error message.
 */
function notFoundError(executable) {
  return `No executable could be found for ${executable}`;
}

/**
 * Resolves the location of an executable given an arbitrary valid string
 * representation of that executable.
 *
 * To obtain the location of the executable this function (if necessary):
 * - Expands the provided string to an absolute path.
 * - Follows symbolic links.
 *
 * @param {object} args The arguments for this function.
 * @param {Object<string, string>} args.env The environment variables.
 * @param {string} args.executable A string representation of the executable.
 * @param {object} deps The dependencies for this function.
 * @param {Function} deps.exists A function to check if a file exists.
 * @param {Function} deps.readlink A function to resolve (sym)links.
 * @param {Function} deps.which A function to perform a `which(1)`-like lookup.
 * @returns {string} The full path to the binary of the executable.
 * @throws {Error} If the executable could not be found.
 */
function resolveExecutable(
  { env, executable },
  { exists, readlink, which },
) {
  let resolved = executable;
  try {
    const path = hasOwn(env, "PATH")
      ? env.PATH
      : hasOwn(env, "Path")
        ? env.Path
        : undefined;
    resolved = which(resolved, { path });
  } catch (_) {
    throw new Error(notFoundError(executable));
  }

  if (!exists(resolved)) {
    throw new Error(notFoundError(executable));
  }

  try {
    resolved = readlink(resolved);
  } catch (_) {
    // An error will be thrown if the executable is not a (sym)link, this is not
    // a problem so the error is ignored
  }

  return resolved;
}

/**
 * @overview Provides functionality for parsing shescape options.
 * @license MPL-2.0
 */


/**
 * The identifier for 'no shell' or the absence of a shell.
 *
 * @constant
 * @type {symbol}
 */
const noShell = Symbol();

/**
 * Build error messages for unsupported shells.
 *
 * @param {string} shellName The full name of a shell.
 * @returns {string} The unsupported shell error message.
 */
function unsupportedError$2(shellName) {
  return `Shescape does not support the shell ${shellName}`;
}

/**
 * Parses options provided to shescape.
 *
 * @param {object} args The arguments for this function.
 * @param {Object<string, string>} args.env The environment variables.
 * @param {object} args.options The options for escaping.
 * @param {object} deps The dependencies for this function.
 * @param {Function} deps.getDefaultShell Function to get the default shell.
 * @param {Function} deps.getShellName Function to get the name of a shell.
 * @param {Function} deps.isShellSupported Function to see if a shell is usable.
 * @returns {object} The parsed arguments.
 * @throws {Error} The shell is not supported or could not be found.
 */
function parseOptions(
  { env, options },
  { getDefaultShell, getShellName, isShellSupported },
) {
  let flagProtection = hasOwn(options, "flagProtection")
    ? options.flagProtection
    : undefined;
  let shell = hasOwn(options, "shell") ? options.shell : undefined;

  flagProtection =
    flagProtection === undefined ? true : flagProtection ? true : false;

  let shellName = noShell;
  if (shell !== false) {
    if (!isString(shell)) {
      shell = getDefaultShell({ env });
    }

    shellName = getShellName({ env, shell }, { resolveExecutable });
  }

  if (!isShellSupported(shellName)) {
    throw new Error(unsupportedError$2(shellName));
  }

  return { flagProtection, shellName };
}

/**
 * @overview Provides functionality for the Bourne-again shell (Bash).
 * @license MPL-2.0
 */

/**
 * Escape an argument for use in Bash.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArg$7(arg) {
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/\\/gu, "\\\\")
    .replace(/(?<=^|\s)([#~])/gu, "\\$1")
    .replace(/(["$&'()*;<>?`{|])/gu, "\\$1")
    .replace(/(?<=[:=])(~)(?=[\s+\-/0:=]|$)/gu, "\\$1")
    .replace(/([\t ])/gu, "\\$1");
}

/**
 * Returns a function to escape arguments for use in Bash for the given use
 * case.
 *
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$9() {
  return escapeArg$7;
}

/**
 * Escape an argument for use in Bash when the argument is being quoted.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForQuoted$5(arg) {
  return arg
    .replace(/[\0\u0008\u001B\u009B]/gu, "")
    .replace(/\r(?!\n)/gu, "")
    .replace(/'/gu, "'\\''");
}

/**
 * Quotes an argument for use in Bash.
 *
 * @param {string} arg The argument to quote.
 * @returns {string} The quoted argument.
 */
function quoteArg$5(arg) {
  return `'${arg}'`;
}

/**
 * Returns a pair of functions to escape and quote arguments for use in Bash.
 *
 * @returns {Function[]} A function pair to escape & quote arguments.
 */
function getQuoteFunction$9() {
  return [escapeArgForQuoted$5, quoteArg$5];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Unix systems for Bash.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix$7(arg) {
  return arg.replace(/^-+/gu, "");
}

/**
 * Returns a function to protect against flag injection for Bash.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$9() {
  return stripFlagPrefix$7;
}

/**
 * @overview Provides functionality for the C shell (csh).
 * @license MPL-2.0
 */


/**
 * Escape an argument for use in csh.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArg$6(arg) {
  const textEncoder = new node_util.TextEncoder();
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/\\/gu, "\\\\")
    .replace(/(?<=^|\s)(~)/gu, "\\$1")
    .replace(/!(?!$)/gu, "\\!")
    .replace(/(["#$&'()*;<>?[`{|])/gu, "\\$1")
    .replace(/([\t ])/gu, "\\$1")
    .split("")
    .map(
      // Due to a bug in C shell version 20110502-7, when a character whose
      // utf-8 encoding includes the bytes 0xA0 (160 in decimal) appears in
      // an argument after an escaped character, it will hang and endlessly
      // consume memory unless the character is escaped with quotes.
      // ref: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=995013
      (char) => (textEncoder.encode(char).includes(160) ? `'${char}'` : char),
    )
    .join("");
}

/**
 * Returns a function to escape arguments for use in csh for the given use case.
 *
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$8() {
  return escapeArg$6;
}

/**
 * Escape an argument for use in csh when the argument is being quoted.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForQuoted$4(arg) {
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/'/gu, "'\\''")
    .replace(/\\!$/gu, "\\\\!")
    .replace(/!(?!$)/gu, "\\!");
}

/**
 * Quotes an argument for use in csh.
 *
 * @param {string} arg The argument to quote.
 * @returns {string} The quoted argument.
 */
function quoteArg$4(arg) {
  return `'${arg}'`;
}

/**
 * Returns a pair of functions to escape and quote arguments for use in csh.
 *
 * @returns {Function[]} A function pair to escape & quote arguments.
 */
function getQuoteFunction$8() {
  return [escapeArgForQuoted$4, quoteArg$4];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Unix systems for csh.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix$6(arg) {
  return arg.replace(/^-+/gu, "");
}

/**
 * Returns a function to protect against flag injection for csh.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$8() {
  return stripFlagPrefix$6;
}

/**
 * @overview Provides functionality for the Debian Almquist shell (Dash).
 * @license MPL-2.0
 */

/**
 * Escape an argument for use in Dash.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArg$5(arg) {
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/\\/gu, "\\\\")
    .replace(/(?<=^|\s)([#~])/gu, "\\$1")
    .replace(/(["$&'()*;<>?`|])/gu, "\\$1")
    .replace(/([\t ])/gu, "\\$1");
}

/**
 * Returns a function to escape arguments for use in Dash for the given use
 * case.
 *
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$7() {
  return escapeArg$5;
}

/**
 * Escape an argument for use in Dash when the argument is being quoted.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForQuoted$3(arg) {
  return arg
    .replace(/[\0\u0008\u001B\u009B]/gu, "")
    .replace(/\r(?!\n)/gu, "")
    .replace(/'/gu, "'\\''");
}

/**
 * Quotes an argument for use in Dash.
 *
 * @param {string} arg The argument to quote.
 * @returns {string} The quoted argument.
 */
function quoteArg$3(arg) {
  return `'${arg}'`;
}

/**
 * Returns a pair of functions to escape and quote arguments for use in Dash.
 *
 * @returns {Function[]} A function pair to escape & quote arguments.
 */
function getQuoteFunction$7() {
  return [escapeArgForQuoted$3, quoteArg$3];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Unix systems for Dash.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix$5(arg) {
  return arg.replace(/^-+/gu, "");
}

/**
 * Returns a function to protect against flag injection for Dash.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$7() {
  return stripFlagPrefix$5;
}

/**
 * @overview Provides functionality for shell-less escaping on Unix systems.
 * @license MPL-2.0
 */

/**
 * The error message for use of quoting functionality.
 *
 * @constant
 * @type {string}
 */
const unsupportedError$1 = "Quoting is not supported when no shell is used";

/**
 * Escape an argument for shell-less use.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArg$4(arg) {
  return arg.replace(/[\0\u0008\u001B\u009B]/gu, "").replace(/\r(?!\n)/gu, "");
}

/**
 * Returns a function to escape arguments for shell-less use.
 *
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$6() {
  return escapeArg$4;
}

/**
 * Returns the provided value.
 *
 * @throws {Error} Always.
 */
function unsupported$1() {
  throw new Error(unsupportedError$1);
}

/**
 * Returns a pair of functions that will indicate this operation is unsupported.
 *
 * @returns {Function[]} A pair of functions.
 */
function getQuoteFunction$6() {
  return [unsupported$1, unsupported$1];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Unix systems.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix$4(arg) {
  return arg.replace(/^-+/gu, "");
}

/**
 * Returns a function to protect against flag injection for Unix systems.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$6() {
  return stripFlagPrefix$4;
}

/**
 * @overview Provides functionality for the Z shell (Zsh).
 * @license MPL-2.0
 */

/**
 * Escape an argument for use in Zsh.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArg$3(arg) {
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/\\/gu, "\\\\")
    .replace(/(?<=^|\s)([#=~])/gu, "\\$1")
    .replace(/(["$&'()*;<>?[\]`{|}])/gu, "\\$1")
    .replace(/([\t ])/gu, "\\$1");
}

/**
 * Returns a function to escape arguments for use in Zsh for the given use case.
 *
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$5() {
  return escapeArg$3;
}

/**
 * Escape an argument for use in Zsh when the argument is being quoted.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForQuoted$2(arg) {
  return arg
    .replace(/[\0\u0008\u001B\u009B]/gu, "")
    .replace(/\r(?!\n)/gu, "")
    .replace(/'/gu, "'\\''");
}

/**
 * Quotes an argument for use in Zsh.
 *
 * @param {string} arg The argument to quote.
 * @returns {string} The quoted argument.
 */
function quoteArg$2(arg) {
  return `'${arg}'`;
}

/**
 * Returns a pair of functions to escape and quote arguments for use in Zsh.
 *
 * @returns {Function[]} A function pair to escape & quote arguments.
 */
function getQuoteFunction$5() {
  return [escapeArgForQuoted$2, quoteArg$2];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Unix systems for Zsh.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix$3(arg) {
  return arg.replace(/^-+/gu, "");
}

/**
 * Returns a function to protect against flag injection for Zsh.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$5() {
  return stripFlagPrefix$3;
}

/**
 * @overview Provides functionality for Unix systems.
 * @license MPL-2.0
 */


/**
 * The name of the Bourne-again shell (Bash) binary.
 *
 * @constant
 * @type {string}
 */
const binBash = "bash";

/**
 * The name of the C shell (csh) binary.
 *
 * @constant
 * @type {string}
 */
const binCsh = "csh";

/**
 * The name of the Debian Almquist shell (Dash) binary.
 *
 * @constant
 * @type {string}
 */
const binDash = "dash";

/**
 * The name of the Z shell (Zsh) binary.
 *
 * @constant
 * @type {string}
 */
const binZsh = "zsh";

/**
 * Returns the default shell for Unix systems.
 *
 * For more information, see `options.shell` in:
 * https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback.
 *
 * @returns {string} The default shell.
 */
function getDefaultShell$1() {
  return "/bin/sh";
}

/**
 * Returns a function to escape arguments for use in a particular shell.
 *
 * @param {string | symbol} shellName The name of a Unix shell.
 * @returns {Function | undefined} A function to escape arguments.
 */
function getEscapeFunction$4(shellName) {
  switch (shellName) {
    case noShell:
      return getEscapeFunction$6();
    case binBash:
      return getEscapeFunction$9();
    case binCsh:
      return getEscapeFunction$8();
    case binDash:
      return getEscapeFunction$7();
    case binZsh:
      return getEscapeFunction$5();
  }
}

/**
 * Returns a pair of functions to escape and quote arguments for use in a
 * particular shell.
 *
 * @param {string | symbol} shellName The name of a Unix shell.
 * @returns {Function[] | undefined} A function pair to escape & quote arguments.
 */
function getQuoteFunction$4(shellName) {
  switch (shellName) {
    case noShell:
      return getQuoteFunction$6();
    case binBash:
      return getQuoteFunction$9();
    case binCsh:
      return getQuoteFunction$8();
    case binDash:
      return getQuoteFunction$7();
    case binZsh:
      return getQuoteFunction$5();
  }
}

/**
 * Returns a function to protect against flag injection.
 *
 * @param {string | symbol} shellName The name of a Unix shell.
 * @returns {Function | undefined} A function to protect against flag injection.
 */
function getFlagProtectionFunction$4(shellName) {
  switch (shellName) {
    case noShell:
      return getFlagProtectionFunction$6();
    case binBash:
      return getFlagProtectionFunction$9();
    case binCsh:
      return getFlagProtectionFunction$8();
    case binDash:
      return getFlagProtectionFunction$7();
    case binZsh:
      return getFlagProtectionFunction$5();
  }
}

/**
 * Determines the name of the shell identified by a file path or file name.
 *
 * @param {object} args The arguments for this function.
 * @param {Object<string, string>} args.env The environment variables.
 * @param {string} args.shell The name or path of the shell.
 * @param {object} deps The dependencies for this function.
 * @param {Function} deps.resolveExecutable Resolve the path to an executable.
 * @returns {string} The shell name.
 */
function getShellName$1({ env, shell }, { resolveExecutable }) {
  shell = resolveExecutable(
    { env, executable: shell },
    { exists: fs__namespace.existsSync, readlink: fs__namespace.readlinkSync, which: which.sync },
  );

  const shellName = path__namespace.basename(shell);
  return shellName;
}

/**
 * Checks if the given shell is supported on Unix or not.
 *
 * @param {string} shellName The name of a Unix shell.
 * @returns {boolean} `true` if the shell is supported, `false` otherwise.
 */
function isShellSupported$1(shellName) {
  return getEscapeFunction$4(shellName) !== undefined;
}

var unix = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getDefaultShell: getDefaultShell$1,
  getEscapeFunction: getEscapeFunction$4,
  getFlagProtectionFunction: getFlagProtectionFunction$4,
  getQuoteFunction: getQuoteFunction$4,
  getShellName: getShellName$1,
  isShellSupported: isShellSupported$1
});

/**
 * @overview Provides functionality for the Windows Command Prompt.
 * @license MPL-2.0
 */

/**
 * Escape an argument for use in CMD.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArg$2(arg) {
  let shouldEscapeSpecialChar = true;
  return arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/(?<!\\)(\\*)"/gu, '$1$1\\"')
    .split("")
    .map(
      // Due to the way CMD determines if it is inside a quoted section, and the
      // way we escape double quotes, whether or not special character need to
      // be escaped depends on the number of double quotes that proceed it. So,
      // we flip a flag for every double quote we encounter and escape special
      // characters conditionally on that flag.
      (char) => {
        if (char === '"') {
          shouldEscapeSpecialChar = !shouldEscapeSpecialChar;
        } else if (shouldEscapeSpecialChar && /[%&<>^|]/u.test(char)) {
          return `^${char}`;
        }

        return char;
      },
    )
    .join("");
}

/**
 * Returns a function to escape arguments for use in CMD for the given use case.
 *
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$3() {
  return escapeArg$2;
}

/**
 * Escape an argument for use in CMD when the argument is being quoted.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForQuoted$1(arg) {
  return escapeArg$2(arg).replace(/(?<!\\)(\\*)([\t ])/gu, "$1$1$2");
}

/**
 * Quotes an argument for use in CMD.
 *
 * @param {string} arg The argument to quote.
 * @returns {string} The quoted argument.
 */
function quoteArg$1(arg) {
  return arg.replace(/([\t ]+)/gu, '"$1"');
}

/**
 * Returns a pair of functions to escape and quote arguments for use in CMD.
 *
 * @returns {Function[]} A function pair to escape & quote arguments.
 */
function getQuoteFunction$3() {
  return [escapeArgForQuoted$1, quoteArg$1];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Windows systems for CMD.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix$2(arg) {
  return arg.replace(/^(?:-+|\/+)/gu, "");
}

/**
 * Returns a function to protect against flag injection for CMD.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$3() {
  return stripFlagPrefix$2;
}

/**
 * @overview Provides functionality for shell-less escaping on Windows systems.
 * @license MPL-2.0
 */

/**
 * The error message for use of quoting functionality.
 *
 * @constant
 * @type {string}
 */
const unsupportedError = "Quoting is not supported when no shell is used";

/**
 * Escape an argument for shell-less use.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArg$1(arg) {
  return arg.replace(/[\0\u0008\u001B\u009B]/gu, "").replace(/\r(?!\n)/gu, "");
}

/**
 * Returns a function to escape arguments for shell-less use.
 *
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$2() {
  return escapeArg$1;
}

/**
 * Returns the provided value.
 *
 * @throws {Error} Always.
 */
function unsupported() {
  throw new Error(unsupportedError);
}

/**
 * Returns a pair of functions that will indicate this operation is unsupported.
 *
 * @returns {Function[]} A pair of functions.
 */
function getQuoteFunction$2() {
  return [unsupported, unsupported];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Windows systems.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix$1(arg) {
  return arg.replace(/^(?:-+|\/+)/gu, "");
}

/**
 * Returns a function to protect against flag injection for Windows systems.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$2() {
  return stripFlagPrefix$1;
}

/**
 * @overview Provides functionality for Windows PowerShell.
 * @license MPL-2.0
 */

/**
 * Escape an argument for use in PowerShell.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArg(arg) {
  arg = arg
    .replace(/[\0\u0008\r\u001B\u009B]/gu, "")
    .replace(/\n/gu, " ")
    .replace(/`/gu, "``")
    .replace(/(?<=^|[\s\u0085])([*1-6]?)(>)/gu, "$1`$2")
    .replace(/(?<=^|[\s\u0085])([#\-:<@\]])/gu, "`$1")
    .replace(/([$&'(),;{|}‘’‚‛“”„])/gu, "`$1");

  if (/[\s\u0085]/u.test(arg.replace(/^[\s\u0085]+/gu, ""))) {
    arg = arg
      .replace(/(?<!\\)(\\*)"/gu, '$1$1`"`"')
      .replace(/(?<!\\)(\\+)$/gu, "$1$1");
  } else {
    arg = arg.replace(/(?<!\\)(\\*)"/gu, '$1$1\\`"');
  }

  arg = arg.replace(/([\s\u0085])/gu, "`$1");

  return arg;
}

/**
 * Returns a function to escape arguments for use in PowerShell for the given
 * use case.
 *
 * @returns {Function} A function to escape arguments.
 */
function getEscapeFunction$1() {
  return escapeArg;
}

/**
 * Escape an argument for use in PowerShell when the argument is being quoted.
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeArgForQuoted(arg) {
  arg = arg
    .replace(/[\0\u0008\u001B\u009B]/gu, "")
    .replace(/\r(?!\n)/gu, "")
    .replace(/(['‘’‚‛])/gu, "$1$1");

  if (/[\s\u0085]/u.test(arg)) {
    arg = arg
      .replace(/(?<!\\)(\\*)"/gu, '$1$1""')
      .replace(/(?<!\\)(\\+)$/gu, "$1$1");
  } else {
    arg = arg.replace(/(?<!\\)(\\*)"/gu, '$1$1\\"');
  }

  return arg;
}

/**
 * Quotes an argument for use in PowerShell.
 *
 * @param {string} arg The argument to quote and escape.
 * @returns {string} The quoted and escaped argument.
 */
function quoteArg(arg) {
  return `'${arg}'`;
}

/**
 * Returns a pair of functions to escape and quote arguments for use in
 * PowerShell.
 *
 * @returns {Function[]} A function pair to escape & quote arguments.
 */
function getQuoteFunction$1() {
  return [escapeArgForQuoted, quoteArg];
}

/**
 * Remove any prefix from the provided argument that might be interpreted as a
 * flag on Windows systems for PowerShell.
 *
 * @param {string} arg The argument to update.
 * @returns {string} The updated argument.
 */
function stripFlagPrefix(arg) {
  return arg.replace(/^(?:`?-+|\/+)/gu, "");
}

/**
 * Returns a function to protect against flag injection for PowerShell.
 *
 * @returns {Function} A function to protect against flag injection.
 */
function getFlagProtectionFunction$1() {
  return stripFlagPrefix;
}

/**
 * @overview Provides functionality for Windows systems.
 * @license MPL-2.0
 */


/**
 * The name of the Windows Command Prompt binary.
 *
 * @constant
 * @type {string}
 */
const binCmd = "cmd.exe";

/**
 * The name of the Windows PowerShell binary.
 *
 * @constant
 * @type {string}
 */
const binPowerShell = "powershell.exe";

/**
 * Returns the default shell for Windows systems.
 *
 * For more information, see:
 * https://nodejs.org/api/child_process.html#default-windows-shell.
 *
 * @param {object} args The arguments for this function.
 * @param {Object<string, string>} args.env The environment variables.
 * @returns {string} The default shell.
 */
function getDefaultShell({ env }) {
  const ComSpec = hasOwn(env, "ComSpec") ? env.ComSpec : undefined;
  if (ComSpec !== undefined) {
    return ComSpec;
  }

  return binCmd;
}

/**
 * Returns a function to escape arguments for use in a particular shell.
 *
 * @param {string | symbol} shellName The name of a Windows shell.
 * @returns {Function | undefined} A function to escape arguments.
 */
function getEscapeFunction(shellName) {
  if (shellName === noShell) {
    return getEscapeFunction$2();
  }

  switch (shellName.toLowerCase()) {
    case binCmd:
      return getEscapeFunction$3();
    case binPowerShell:
      return getEscapeFunction$1();
  }
}

/**
 * Returns a pair of functions to escape and quote arguments for use in a
 * particular shell.
 *
 * @param {string | symbol} shellName The name of a Windows shell.
 * @returns {Function[] | undefined} A function pair to escape & quote arguments.
 */
function getQuoteFunction(shellName) {
  if (shellName === noShell) {
    return getQuoteFunction$2();
  }

  switch (shellName.toLowerCase()) {
    case binCmd:
      return getQuoteFunction$3();
    case binPowerShell:
      return getQuoteFunction$1();
  }
}

/**
 * Returns a function to protect against flag injection.
 *
 * @param {string | symbol} shellName The name of a Windows shell.
 * @returns {Function | undefined} A function to protect against flag injection.
 */
function getFlagProtectionFunction(shellName) {
  if (shellName === noShell) {
    return getFlagProtectionFunction$2();
  }

  switch (shellName.toLowerCase()) {
    case binCmd:
      return getFlagProtectionFunction$3();
    case binPowerShell:
      return getFlagProtectionFunction$1();
  }
}

/**
 * Determines the name of the shell identified by a file path or file name.
 *
 * @param {object} args The arguments for this function.
 * @param {Object<string, string>} args.env The environment variables.
 * @param {string} args.shell The name or path of the shell.
 * @param {object} deps The dependencies for this function.
 * @param {Function} deps.resolveExecutable Resolve the path to an executable.
 * @returns {string} The shell name.
 */
function getShellName({ env, shell }, { resolveExecutable }) {
  shell = resolveExecutable(
    { env, executable: shell },
    { exists: fs__namespace.existsSync, readlink: fs__namespace.readlinkSync, which: which.sync },
  );

  const shellName = path__namespace.win32.basename(shell);
  return shellName;
}

/**
 * Checks if the given shell is supported on Windows or not.
 *
 * @param {string} shellName The name of a Windows shell.
 * @returns {boolean} `true` if the shell is supported, `false` otherwise.
 */
function isShellSupported(shellName) {
  return getEscapeFunction(shellName) !== undefined;
}

var win = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getDefaultShell: getDefaultShell,
  getEscapeFunction: getEscapeFunction,
  getFlagProtectionFunction: getFlagProtectionFunction,
  getQuoteFunction: getQuoteFunction,
  getShellName: getShellName,
  isShellSupported: isShellSupported
});

/**
 * @overview Provides functionality related to getting the platform module for
 * the current system.
 * @license MPL-2.0
 */


/**
 * The string identifying the OS type Cygwin.
 *
 * @constant
 * @type {string}
 */
const cygwin = "cygwin";

/**
 * The string identifying the OS type MSYS.
 *
 * @constant
 * @type {string}
 */
const msys = "msys";

/**
 * The string identifying Windows platforms.
 *
 * @constant
 * @type {string}
 */
const win32 = "win32";

/**
 * Checks if the current system is a Windows system.
 *
 * @param {object} args The arguments for this function.
 * @param {Object<string, string>} args.env The environment variables.
 * @param {string} args.platform The `os.platform()` value.
 * @returns {boolean} `true` if the system is Windows, `false` otherwise.
 */
function isWindow({ env, platform }) {
  const osType = hasOwn(env, "OSTYPE") ? env.OSTYPE : undefined;
  return osType === cygwin || osType === msys || platform === win32;
}

/**
 * Returns all helper functions for a specific system.
 *
 * @param {object} args The arguments for this function.
 * @param {Object<string, string>} args.env The environment variables.
 * @param {string} args.platform The `os.platform()` value.
 * @returns {object} The helper functions for the current system.
 */
function getHelpersByPlatform({ env, platform }) {
  if (isWindow({ env, platform })) {
    return win;
  }

  return unix;
}

/**
 * A simple shell escape library. Use it to escape user-controlled inputs to
 * shell commands to prevent shell injection.
 *
 * @overview Entrypoint for the library.
 * @module shescape
 * @version 2.0.2
 * @license MPL-2.0
 */


/**
 * A class to escape user-controlled inputs to shell commands to prevent shell
 * injection.
 *
 * @example
 * import { spawn } from "node:child_process";
 * const shescape = new Shescape({ shell: false });
 * spawn(
 *   "echo",
 *   ["Hello", shescape.escape(userInput)],
 *   null // `options.shell` MUST be falsy
 * );
 * @example
 * import { spawn } from "node:child_process";
 * const shescape = new Shescape({ shell: false });
 * spawn(
 *   "echo",
 *   shescape.escapeAll(["Hello", userInput]),
 *   null // `options.shell` MUST be falsy
 * );
 * @example
 * import { spawn } from "node:child_process";
 * const spawnOptions = { shell: true }; // `options.shell` SHOULD be truthy
 * const shescape = new Shescape({ shell: spawnOptions.shell });
 * spawn(
 *   "echo",
 *   ["Hello", shescape.quote(userInput)],
 *   spawnOptions
 * );
 * @example
 * import { spawn } from "node:child_process";
 * const spawnOptions = { shell: true }; // `options.shell` SHOULD be truthy
 * const shescape = new Shescape({ shell: spawnOptions.shell });
 * spawn(
 *   "echo",
 *   shescape.quoteAll(["Hello", userInput]),
 *   spawnOptions
 * );
 */
class Shescape {
  /**
   * Create a new {@link Shescape} instance.
   *
   * @param {object} [options] The escape options.
   * @param {boolean} [options.flagProtection=true] Is flag protection enabled.
   * @param {boolean | string} [options.shell=true] The shell to escape for.
   * @throws {Error} The shell is not supported or could not be found.
   * @since 2.0.0
   */
  constructor(options = {}) {
    const platform = os.platform();
    const helpers = getHelpersByPlatform({ env: process.env, platform });

    options = parseOptions({ env: process.env, options }, helpers);
    const { flagProtection, shellName } = options;

    {
      const escape = helpers.getEscapeFunction(shellName);
      if (flagProtection) {
        const flagProtect = helpers.getFlagProtectionFunction(shellName);
        this._escape = (arg) => flagProtect(escape(arg));
      } else {
        this._escape = escape;
      }
    }

    {
      const [escape, quote] = helpers.getQuoteFunction(shellName);
      if (flagProtection) {
        const flagProtect = helpers.getFlagProtectionFunction(shellName);
        this._quote = (arg) => quote(flagProtect(escape(arg)));
      } else {
        this._quote = (arg) => quote(escape(arg));
      }
    }
  }

  /**
   * Take a single value, the argument, and escape any dangerous characters.
   *
   * Non-string inputs will be converted to strings using a `toString()` method.
   *
   * @param {string} arg The argument to escape.
   * @returns {string} The escaped argument.
   * @throws {TypeError} The argument is not stringable.
   * @since 2.0.0
   */
  escape(arg) {
    const argAsString = checkedToString(arg);
    return this._escape(argAsString);
  }

  /**
   * Take an array of values, the arguments, and escape any dangerous characters
   * in every argument.
   *
   * Non-string inputs will be converted to strings using a `toString()` method.
   *
   * @param {string[]} args The arguments to escape.
   * @returns {string[]} The escaped arguments.
   * @throws {TypeError} The arguments are not an array.
   * @throws {TypeError} One of the arguments is not stringable.
   * @since 2.0.0
   */
  escapeAll(args) {
    return args.map((arg) => this.escape(arg));
  }

  /**
   * Take a single value, the argument, put shell-specific quotes around it and
   * escape any dangerous characters.
   *
   * Non-string inputs will be converted to strings using a `toString()` method.
   *
   * @param {string} arg The argument to quote and escape.
   * @returns {string} The quoted and escaped argument.
   * @throws {TypeError} The argument is not stringable.
   * @throws {Error} Quoting is not supported with `shell: false`.
   * @since 2.0.0
   */
  quote(arg) {
    const argAsString = checkedToString(arg);
    return this._quote(argAsString);
  }

  /**
   * Take an array of values, the arguments, put shell-specific quotes around
   * every argument and escape any dangerous characters in every argument.
   *
   * Non-string inputs will be converted to strings using a `toString()` method.
   *
   * @param {string[]} args The arguments to quote and escape.
   * @returns {string[]} The quoted and escaped arguments.
   * @throws {TypeError} The arguments are not an array.
   * @throws {TypeError} One of the arguments is not stringable.
   * @throws {Error} Quoting is not supported with `shell: false`.
   * @since 2.0.0
   */
  quoteAll(args) {
    return args.map((arg) => this.quote(arg));
  }
}

exports.Shescape = Shescape;
